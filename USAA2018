Run Length Encoding 

#include <stdio.h>
#include <string.h>

int main(){
    int head  = -1;
    int length = 0;
    while(1){
        int c = getchar();
        if (c == EOF){
            printf("%c",head);
            printf("%c",length);
            break;
        }
        if (c == head){
            length += 1;
        }
        else {
            printf("%c",head);
            printf("%c",length);
            head = c;
            length = 1;
        }
    }
    return 0;
}
-----------------------------------------------

              
Word Counter 

#include <stdio.h>
#include <string.h>
void main()
{
    char s[200];
    int count = 0, i;
    printf("enter the string\n");
    scanf("%[^\n]s", s);
    for (i = 0;s[i] != '\0';i++)
    
        if (s[i] == ' ')
            count++;    
    
    printf("number of words in given string are: %d\n", count + 1);
}
-------------------------------------------------------------


Linked List  
Vytvorí spojkový zoznam(hladek)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


 struct todolist {
    char task[12];
    struct todolist* next;

};

struct todolist* create(struct todolist* next,const char* task) {
    struct todolist* n = calloc(1,sizeof(struct todolist));
    strcpy(n->task,task);
    n->next = next;
    return n;
}

1.Vytvori jednoprvkovy spojkovy zoznam
struct list* create_list(int data){
      struct list* head = NULL;
      head=(struct list*) malloc(sizeof(struct list));
      head->data=1;
      head->next=NULL;
      return head;
}


2. Zrušenie všetkých prvkov zoznamu

void destroy_list(struct list* list) {
 
 if(list != NULL){
  destroy_list(list->next);
  free(list);
 }   
}



3. Vymazanie posledného prvku zoznamu

struct list* pop_list(struct list* list, int* value) 
{ 
    struct list *temp = list, *ptr = NULL; 

    if (list == NULL){
     return NULL;
    }

    while (temp) { 

        if (temp->data == value)  
            ptr = temp;         
        temp = temp->next; 
    } 
  
    if (ptr != NULL && ptr->next == NULL) { 
        temp = list; 
        while (temp->next != ptr)  
            temp = temp->next;        
        temp->next = NULL; 
    } 
  
    if (ptr != NULL && ptr->next != NULL) { 
        ptr->data = ptr->next->data; 
        temp = ptr->next; 
        ptr->next = ptr->next->next; 
        free(temp); 
    } 
return list;
} 



4. Pridá prvok na koniec zoznamu
struct list* push_list(struct list* list, int data)//data=value,list=head
{
    struct list *newList = (struct list *) malloc(sizeof(struct list));
    newList->data = data;
    newList->next = NULL;

    if (list == NULL) {
        // Pridanie na zaciatok
        list = newList;
    } else {
        list *current = list;

        while (current->next != NULL) {
            current = current->next;
        }

        // Pridanie na koniec
        current->next = newList;
    }

    return list;
}



5. Pridá prvok na začiatok zoznamu (shift)

struct list* shift_list(struct list* list,int data)
{
    struct list* tmp = (struct list*)malloc(sizeof(struct list));
    if(tmp == NULL)
    {
        exit(0);
    }
    tmp->data = data;
    tmp->next = list;
    list = tmp;
    return list;
}



6. Vymazanie prveho prvku zo zoznamu (unshift)

struct list* unshift_list(struct list* list,int* value)
{
    struct list* tmp = list;
    *value = list->data;
    list = list->next;
    free(tmp);
    return list;
}



7. Vypísanie zoznamu

void print_list(struct todolist* list){
    for (struct todolist* this = list; this != NULL; this = this->next){
        printf("%s\n",this->task);
    }

}

 int main(){

     struct todolist* one = add_start(NULL,"Studujem");
//
    struct todolist* two = add_start(one,"Vstanem");

     print_list(two);
    delete_list(two);
//    one.next = &two;
//
//    process(one);


    return 0;

--------------------------------------------------------------

Asociatívne pole (Hashovacia funkcia)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct item {
    char key[20];
    int value;
    struct item* next;
};

struct table {
    struct item** slots;
    int slot_count;
};

struct table* create_table(){
    struct table* tab = malloc(sizeof(struct table));
    tab->slot_count = 40;
    tab->slots = calloc(tab->slot_count,sizeof(struct item *));
    return tab;
}

void destroy_table(struct table* tab){
    for (int i = 0; i < tab->slot_count; i++){
        struct item* list = tab->slots[i];
        while (list != NULL){
            struct item* del = list;
            list = del->next;
            free(del);
        }
    }
    free(tab->slots);
    free(tab);
}



int hash_string(const char* word){
    int hash = 0;
    for (int counter = 0; word[counter]!='\0'; counter++){
        hash = word[counter] + (hash << 6) + (hash << 16) - hash;
    }
    return hash;
}

int insert(struct table* tab,const char* key,int value){
    int hash = hash_string(key); 
    int slot_index = hash % tab->slot_count;

    struct item* slot = tab->slots[slot_index];
    while (slot != NULL){
        if (strcmp(slot->key,key) == 0) {
            slot->value = value;
            return 1;
        }
        slot = slot->next;
    }
    struct item* new = malloc(sizeof(struct item));
    strcpy(new->key,key);
    new->value = value;
    new->next = slot;
    tab->slots[slot_index] = new;
    if (new->next){
        return 1;
    }
    return 0;
}



int* find(struct table* tab,const char* key){
    int hash = hash_string(key); 
    int slot_index = hash % tab->slot_count;

    struct item* slot = tab->slots[slot_index];
    while (slot != NULL){
        if (strcmp(slot->key,key) == 0) {
            return &(slot->value);
        }
        slot = slot->next;
    }
    return NULL;
}

int* delete(struct table* tab,const char* key){
    int hash = hash_string(key); 
    int slot_index = hash % tab->slot_count;

    struct item* slot = tab->slots[slot_index];

    if(slot != NULL){
        struct item* this = slot;
        while (this->next != NULL){
            if (strcmp(this->next->key,key) == 0) {
            }
            this = this->next;
        }
    }
    return NULL;
}

int main(){
    struct table* tab = create_table();
    insert(tab,"ahoj",2);
    insert(tab,"svet",4);

    int* val = NULL;
    val = find(tab,"kluc");

    destroy_table(tab);
    return 0;
}

------------------------------------------------------------------

Načítanie zo štandardného vstupu (klávesnica) 

int read_line(char* line, int size){
for (int i = 0; i< size-1; i++){
      int c = getchar();
      if (c == EOF){
          line[i]=0;
          return EOF;
      }
      else if (c == '\n'){
           line[i] = c;
           line[i+1] = 0;
           return i + 1;
      }
      line[i] = c;
}
  return size - 1;
}

----------------------------------------------------------------

Načítanie zo súboru 

int read_line(FILE* file,char* line, int size) {

    for (int i = 0; i< size-1; i++){
        int c = getc(file);
        if (c == EOF){
           line[i]=0;
           return EOF;
        }
        else if (c == '\n'){
            line[i] = c;
            line[i+1] = 0;
            return i + 1;
        }
        line[i] = c;
    }

  return size - 1;
}
--------------------------------------------------------------------

Binárny strom

struct node{
  int key_value;
  struct node *left;
  struct node *right;
};

struct node *root = 0;

void destroy_tree(struct node *leaf){
  if( leaf != 0 )
  {
      destroy_tree(leaf->left);
      destroy_tree(leaf->right);
      free( leaf );
  }
}

insert(int key, struct node **leaf)
{
    if( *leaf == 0 )
    {
        *leaf = (struct node*) malloc( sizeof( struct node ) );
        (*leaf)->key_value = key;
        /* initialize the children to null */
        (*leaf)->left = 0;    
        (*leaf)->right = 0;  
    }
    else if(key < (*leaf)->key_value)
    {
        insert( key, &(*leaf)->left );
    }
    else if(key > (*leaf)->key_value)
    {
        insert( key, &(*leaf)->right );
    }
}



struct node *search(int key, struct node *leaf){
  if( leaf != 0 )
  {
      if(key==leaf->key_value)
      {
          return leaf;
      }
      else if(key<leaf->key_value)
      {
          return search(key, leaf->left);
      }
      else
      {
          return search(key, leaf->right);
      }
  }
  else return 0;
}
